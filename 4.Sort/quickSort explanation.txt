Суть алгоритма
Выбираем в массиве «опорный» элемент. Им может быть абсолютно любой элемент из массива, однако чуть дальше мы поговорим о том, как его выбор влияет на время выполнения.
Сравниваем каждый из элементов массива с опорным элементом и по результату сравнений переставляем элементы в нашем массиве так, чтобы слева от опорного были все элементы меньше него, а справа — больше или равны.
Запускаем этот же алгоритм рекурсивно на левую и правую части массива, пока не придём к массиву из одного элемента.
Можно заметить, что этот алгоритм разделяет наши данные на части и «властвует» над каждой из них! Вот и ещё один алгоритм в копилку Divide-and-Conquer. А из-за того, что элементы могут перемешаться в процессе «перекидывания» вокруг опорного элемента, эта сортировка не является устойчивой.